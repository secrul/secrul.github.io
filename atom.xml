<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://secrul.github.io</id>
    <title>secrul</title>
    <updated>2020-08-25T02:19:42.444Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://secrul.github.io"/>
    <link rel="self" href="https://secrul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://secrul.github.io/images/avatar.png</logo>
    <icon>https://secrul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, secrul</rights>
    <entry>
        <title type="html"><![CDATA[SPP-Net]]></title>
        <id>https://secrul.github.io/post/spp-net/</id>
        <link href="https://secrul.github.io/post/spp-net/">
        </link>
        <updated>2020-08-24T07:58:14.000Z</updated>
        <content type="html"><![CDATA[<p>我们在用图像数据训练模型的时候，必须将图像裁剪成统一的大小。SPP-Net就是解决了这样一个问题，使用SPP-Net后，输入的图像数据不需要进行裁剪或者伸缩。但是同一个batch里的数据还是需要大小相同。<br>
之所以我们需要将数据预处理为相同的大小，是因为全连接层需要指定输入的大小，这涉及到我们模型得参数设置。<br>
<img src="https://secrul.github.io/post-images/1598273547488.png" alt="" loading="lazy"><br>
下面来解释一些SPP-Net为什么可以做到：<br>
假如我们需要全连接层的输入是21x1的tensor，SPP-Net的目标就是将一个不知大小的图像转化为21x1的tensor。<br>
<img src="https://secrul.github.io/post-images/1598273741749.png" alt="" loading="lazy"><br>
我们将21分解为16+4+1，然后用一个kernal_size为原图像大小的pooling层(可以是maxpooling、avgpooling)取样，同理用原图像大小二分之一和四分之一的pooling进行取样，得到4和16个数据，最后拼接即可。<br>
**关键点：**使用kernal_size可变得pooling进行取样。POOLing层没有参数，所以可以设置为动态<br>
缺点：和R-CNN一样，它的训练要经过多个阶段，特征也要存在磁盘中，另外，SPP中的微调只更新SPP层后面的全连接层，不适用于深层网络。<br>
SPP-Net用于物体检测：</p>
<ol>
<li>和R-CNN一样，用Selective-search方法选出2000个候选框</li>
<li>与R-CNN不同，不用Resize，整张图片直接卷积，得到一个feature map。然后根据候选框提取特征向量</li>
<li>SVM分类，打分</li>
<li>非极大值NMS分类</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FAST R-CNN]]></title>
        <id>https://secrul.github.io/post/fast-r-cnn/</id>
        <link href="https://secrul.github.io/post/fast-r-cnn/">
        </link>
        <updated>2020-08-24T07:29:40.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SIFT]]></title>
        <id>https://secrul.github.io/post/sift/</id>
        <link href="https://secrul.github.io/post/sift/">
        </link>
        <updated>2020-08-23T01:27:14.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Histograms of Oriented Gradients for Human Detection]]></title>
        <id>https://secrul.github.io/post/histograms-of-oriented-gradients-for-human-detection/</id>
        <link href="https://secrul.github.io/post/histograms-of-oriented-gradients-for-human-detection/">
        </link>
        <updated>2020-08-23T00:58:59.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Eﬃcient Graph-Based Image Segmentation]]></title>
        <id>https://secrul.github.io/post/efficient-graph-based-image-segmentation/</id>
        <link href="https://secrul.github.io/post/efficient-graph-based-image-segmentation/">
        </link>
        <updated>2020-08-20T01:19:55.000Z</updated>
        <content type="html"><![CDATA[<p>#概要<br>
本篇文章解决了图像分割得问题。我们定义了一个谓词，它基于图像的图表示来度量两个区域的边界。我们基于这个谓词提出了一个高效图像分割算法，并且尽管这个算法是贪心的，但是分割结果也满足一些全局属性。我们应用这个算法来分割，使用两种不同局部邻域构造方法，并分别在真实图像和合成图像上展示效果。这个算法的时间复杂度基本上是关于图中边数目的线性时间，在实际中很快。该方法的一个重要特点是能够在低可变性图像区域保留细节，而在高可变性区域忽略细节。<br>
#导论<br>
图像分割和分组任务对于计算机视觉来说仍然是一个很大的挑战。自从格式塔心理学提出后，人类视觉感知中的“完整性感知”就被熟知。原则上，大量的计算视觉问题可以很好地利用分割后的图像，只要这些分割是可靠和高效的。例如，中级视觉问题，如立体和运动估计，需要一个适当的区域来支持对应操作。对于空间上不支持上述任务的区域可以先用分割技术来处理。更高层次的问题，如识别和图像索引，也可以利用分割结果进行匹配，以解决诸如语义分割与识别任务。(ﬁgure-ground指格式塔心理学的一个表现形式，https://en.wikipedia.org/wiki/Figure%E2%80%93ground_(perception))<br>
我们的目标是开发一种广泛使用的图像分割计算方法，其使用方式与在许多计算机视觉任务中使用的其他低级技术（例如边缘检测）的方式非常相似。 为了实现如此广泛的用途，我们认为分割方法必须具有以下属性，这一点很重要：<br>
1. 捕捕捉感知上重要的分组或区域，这些区域通常反映图像的全局方面。两个中心问题是提供对感知上重要的东西的精确描述，以及能够指定给定分割技术的作用。我们认为，为了更好地理解该方法并促进不同方法的比较，应精确定义结果分割的属性。<br>
2. 效率高，运行时间与图像像素数几乎成线性关系。为了实际应用，我们认为分割方法应该以类似于边缘检测或其他低级视觉处理技术的速度运行，这意味着时间几乎是线性的，并且具有低常数因子。例如，以每秒几帧的速度运行的分割技术可用于视频处理应用程序。<br>
在过去的几年中，有很多的基于特征向量的分割方法，这些方法太慢了，不能实际使用。相反，本篇论文中描述的方法可以用于大规模图片数据集。也有一些其他高效的图像分割方法，然后这些方法都不能捕捉像下方这幅图像的非局部感知信息。我们所提出的分割技术既能捕获一些重要的感知非局部特性，计算也很高效，可以达到O(nlgn)，可以用于视频分割。<br>
和一些典型的聚类方法一样，我们的方法从一个无向图模型中选择边。模型中节点代表图像的像素点。每一个边的权值代表两个端节点的相异程度。然而不向典型的方法，我们的方法基于图像邻域的多项程度，自适应地调整分割标准。这就产生了一种方法，在做出贪婪决策时，可以证明符合某些不明显的全局属性。我们还表明，其他与本文提出的自适应准则密切相关的自适应准则会导致计算困难（NP-hard）的问题。<br>
我们现在使用一个简单地合成图来说明我们地分割方法所捕获的非局部特征。看到图1中左上角的图片，很多人会认为这幅图包含三个部分，左边是一个灰度递增的矩形，右边是一个均匀灰度的矩形，其中包含了一个灰度变换很大的矩形。这个例子展示了我们认为一个分割方法应该捕获的感知上的重要属性。首先，灰度变化很大的区域不应该划分为多个区块。左边递增区域和右边中心区域灰度值变化都很大，因此，不能假定这些区域有稳定或变化很慢的灰度。<br>
图1所说明的另一个感知上重要的方面是这三个有意义的区域并不能 仅仅使用局部评判准则来识别。这是因为左边灰度递增区域和右边恒定区域的边界差异实际上要比右侧灰度变化剧烈区域的差异要小。因此为了分割这样的图像，必须使用非局部自适应算法。<br>
我们在3.1节提出的方法通过比较两个量来评判两个区域之间是不是有边界。第一个是边界两边的灰度值差异，第二个是每个区域内相邻像素之间的灰度差异。直觉上，如果两个区域之间的强度差异相对于至少一个区域内的强度差异较大，则在感知上很重要。我们基于这个思路提出了一个简单的算法。图1中剩余的三幅图像分别是我们算法的分割效果。尽管我们的算法是基于贪心策略，但它也能识别一些源于底层的全局属性，这点可以从图1中看出来。并且我们的方法在320x240的图像上运行时间也很短。<br>
本篇论文的结构如下，在下一章我们会讨论一些相关的工作，包括经典的分割公式和最近的基于图的方法。我们思考一个图像分割问题中特殊的基于图的公式，并定义了一个成对区域比较谓词。在第四节，我们提出基于这个谓词的高效的图像分割算法，并推导出一些它所遵循的全局属性，尽管它是贪心的。在第5节中，我们展示了一些图像的结果，这些图像使用图像网格来构建图像数据的基于图形的表示。然后在第6节中，我们使用更一般的图来说明该方法，但其中边的数量相对于像素点数目仍然是线性的。使用后一种方法产生的结果可以捕捉高级场景属性，例如将底层提取为单个区域，同时仍保留图像其他部分的细节。在附录中，我们展示了在第3节中提出的区域比较谓词的直接推广使得找到一个好的分割NP困难的问题。<br>
#2、相关工作<br>
30年来，有很多关于分割和聚类的文献，这些不仅仅局限于计算机视觉领域。在这一章，我们简短的介绍一些和我们方法最相关工作：早期基于图的方法、区域合并技术、基于将图像像素映射到某些特征空间的技术、最近的图像切割公式以及光谱方法。<br>
基于图的图像分割技术通常用图G=（V，E）表示，其中每个节点vi∈V对应于图像中的一个像素，E中的边缘连接若干对相邻像素。每个边都有一个权重，代表两端像素点某个属性(如如灰度)的关系。根据方法的不同，没对顶点之间可能存在一条边，可能也没有。早期的图像分割方向使用固定的阈值和局部度量，Zahn的方法基于最小生成树，这个方法被应用于图像分割和像素点聚类。对于图像分割技术，边的权值是像素点灰度值的差异，但对于点聚类权值是像素点之间的距离。<br>
Zahn方法的分割准则就是断开最小生成树上最大的边来进行分割。但是可以从图1中看出粗暴断开最大边的不足。如引言中所述，高可变性区域内像素之间的差异可能大于渐变区域和恒定区域之间的差异。因此，根据阈值，简单地断开大的权重边缘将导致高可变性区域被分割成多个区域，或者将渐变和恒定区域合并在一起。Urquhart[15]提出的算法试图解决这一缺点，通过使用与边缘接触的顶点的最小权重来规范化边的权重。然而，当应用于图像分割问题时，这还不足以提供一个合理的自适应分割准则。<br>
早期的另一种图像分割的思路是先分割然后按照一定的标准进行合并。一般来说，一致性准则对于整个子集都使用。例如，一个一致性谓词U(A)对于A集合为真，那么对于所有的A的子集B来说，该谓词U(B)全为真。通常这样的标准都是一致的灰度或者一致的梯度。由于高变化区域的存在，迄今为止提出的区域一致性准则不能用于正确分割图1中的示例。这个区域要么被分割成碎片，要么与周围的区域合并。<br>
很多的分割方法通过在一个特征空间找到一个聚类标准。这些方法通常假定图像是分段的常数，因为在某些特征空间中搜索所有接近的像素隐含地要求像素相似（例如，相似的颜色）。最近一种使用特征空间聚类的技术首先通过平滑数据以保持区域之间的边界来变换数据。这种平滑操作的总体效果是使同一簇内的点更近。这个方法通过将每个点用固定的半径膨胀为超球体，然后找这些超球体的相交部分来聚类。这个聚类的技术并不要求同一类中的点在固定距离以内。这个技术很接近我们要在3.1节介绍的区域比较谓语，只是我们所提出的方法是自调节选择一个合适的膨胀半径。<br>
最后，我们认为图像分割是基于寻找图的最小割集，最小化类别之间的相似性。Wu和Leahy介绍一个一个分割标准，但它偏向于发现小区域。这种偏差通过Shi和Malik[14]提出的归一化切割准则来解决，该准则考虑了区域的自相似性。与早期的基于图的分割方法相比，这些基于切割的分割方法捕捉了图像的非局部特性。然而，它们只提供了每个切割的特征，而不是最终分割的特征。<br>
归一化切割准则相比与以往的方法不管是理论上还是实际应用中都有一个重要的进步——最后分割结果直观上抓住了最显著的部分。但是归一化切割也是一个NP难问题。虽然Shi和Malik提出了计算最小归一化切割的近似方法，但这些近似中的误差并没有得到很好的解释。在实践中，这些近似值仍然很难计算，使得该方法用于相对较小的图像，对于大图像需要几分钟的计算时间。最近，Weiss[16]展示了Shi和Malik提出的基于特征向量的近似与图上更标准的谱划分方法的关系。然而，所有这些方法对于许多实际应用来说都太慢了。<br>
图切割方法的另一种替代是在嵌入图像平面的图中寻找循环。例如在[10]中，每个循环的质量都是以一种与标准化切割方法密切相关的方式规范化的。<br>
#3、基于图的分割<br>
我们提出一种基于图的分割方法。G=(V, E)，代表无向图，V是顶点集，E是边集，我们对顶点集V进行划分。每一个边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">E_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都有一个非负权重,W(E_{ij})代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>两个端点的相异度。在第5节和第6节中，我们考虑了用于图像分割的特殊边缘集和权重函数。然而，这里的公式与这些定义无关。<br>
在基于图的分割方法中，一个分割S是对顶点集V元素的子集划分，每一个子集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">G&#x27; = (C, E&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，C是V的子集，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">E&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>也是E的子集。有很多种方法一个 分割的质量，但大体上我们希望同一个子集中元素更接近，不同子集元素差别更大。意味着同一子集的顶点之间的边的权值应该尽量小，不同子集顶点之间边的权值尽量大。<br>
##3.1、成对区域比较谓词<br>
在这一部分我们提出了一个谓词D，评判两个部分之间是否存在一个边界。该谓词将边界两边集合元素之间的差异性和两个部分内部每个相邻元素之间的差异性相比较。谓词将子集间差异与子集内差异进行比较，从而根据数据的局部特征进行自适应。<br>
我们定义子集C(C<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⫅</mo></mrow><annotation encoding="application/x-tex">\subseteqq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mrel amsrm">⫅</span></span></span></span>V)的内部差异是最小生成树里的最大权重。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>e</mi><mo>⫅</mo><mi>M</mi><mi>S</mi><mi>T</mi><mo>(</mo><mi>C</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow></msub><mi>w</mi><mo>(</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Int(C) = max_{e\subseteqq MST(C,E)} w(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.113362em;vertical-align:-0.3633619999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5157190000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mrel amsrm mtight">⫅</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3633619999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><br>
我们定义两个子集C1，C2之间差异是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>f</mi><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>w</mi><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Dif(C_1,C_2) = min(w(v_i,v_j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>属于子集C1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>属于子集C2.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>V</mi><mi>j</mi><mo>)</mo><mo>⫅</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(V_i,Vj) \subseteqq E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⫅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 如果子集C1和C2之间没有元素相互连接，定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>f</mi><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">Dif(C_1,C_2) = \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 这种方法原则上可能有问题，因为它反应的仅仅是子集间最小边的权值。但是实际中我们发现效果相当好。并且使用其他中位数或者其他分位数可以增加鲁棒性，但这使得问题变成NP难问题。分割标准的小小改变极大的改变了问题的复杂性。<br>
区域比较谓词通过检查子集之间的差异Dif（C1，C2）是否相对于至少一个组件（Int（C1）和Int（C2）中的内部差异较大，来判断一对子集之间是否存在边界。阈值函数用于控制子集之间的差异必须大于最小内部差异的程度。我们将成对比较谓词定义为，<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>if Dif(C1,C2)&gt; MInt(C1,C2)</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">D(C_1,C_2) = \begin{cases} true&amp; \text{if Dif(C1,C2)&gt; MInt(C1,C2)}\\ false&amp; \text{otherwise} \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if Dif(C1,C2)&gt; MInt(C1,C2)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mn>1</mn><mo separator="true">,</mo><mi>C</mi><mn>2</mn><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>I</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mn>1</mn><mo>)</mo><mo>+</mo><mi>t</mi><mo>(</mo><mi>C</mi><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>I</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mn>2</mn><mo>)</mo><mo>+</mo><mi>t</mi><mo>(</mo><mi>C</mi><mn>2</mn><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Mint(C1,C2) = min(Int(C1)+t(C1), Int(C2)+t(C2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>,阈值函数t(C)控制着两个子集之间的相似程度。Int(C)不能很好表达出集合的特征，例如当集合C只有一个元素，Int(C)为0，显然不合理。我们使用阈值函数来调节，t(C) = k / |C|, k是一个常数。也就是说，对于小部件，我们需要更有力的边界证据。在实践中，k设置了一个观察范围，因为k越大，就越倾向于使用更大的组件。但是请注意，k不是最小组件尺寸。当相邻组件之间的差异非常大时，允许使用较小的组件。<br>
任何一个分量的非负函数都可以用于τ，而不需要改变第4节中的算法结果。例如，可以通过定义τ，使分割方法更倾向于某些形状的组件，对于不符合某些期望形状的组件，τ值较大，而对于具有特定形状的组件，τ较小。这将导致分割算法积极地合并形状不理想的组件。这种形状偏好可能与偏好不长且薄的构件一样弱（例如，使用周长与面积的比率），也可能与偏好与特定形状模型匹配的构件一样强烈。请注意，这样做的结果不仅仅是所需形状的组件，但是对于任何两个相邻组件，其中一个组件将是所需形状的组件。<br>
#4、算法及其性质<br>
在本节中，我们将描述和分析一种使用上述决策准则D生成分割的算法。根据以下定义，我们将证明由该算法生成的分割既不太粗也不太细。<br>
定义一：如果没有足够的证据说明区域一和区域二之间有边界的存在，那么这个分割就太精细了<br>
定义二：当一个分割可以进一步划分为不太精细的分割时，该分割就太粗糙了.(即可以继续划分)<br>
性质一：对于任何图来说，都存在一个既不精细又不粗糙的分割<br>
现在我们考虑分割算法，它和Kruskal的最小生成树算法密切相关。它可以在O（mlogm）时间内运行，其中m是图中的边数。<br>
算法一：输入 是图G(V, E)，n个顶点m条边。输入是顶点V的一个分割<br>
0. 对于权值E进行非递减排序<br>
1. 开始每个顶点各自为一组<br>
2. 重复第三步<br>
3. 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mi mathvariant="normal">和</mi><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_i和V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之间有一条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">E_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>联系，并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mi mathvariant="normal">和</mi><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_i和V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不属于同一集合且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><msub><mi>E</mi><mi>q</mi></msub></msub></mrow><annotation encoding="application/x-tex">W_{E_q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03065em;vertical-align:-0.34731999999999996em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833100000000004em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span></span></span></span>是比两个集合内部的距离Int(C)更小，那么合并这两个集合。<br>
我门使用算法 一得到一个分割，遵循既不太精细又不粗糙的全局特性。尽管这个算法是贪心的，但结果还是满足这些全局性质。此外，我们还证明了在该算法的第0步中选择的任何可能的非减边缘权重排序都会产生相同的分割结果。<br>
##4.1算法实现和时间复杂度<br>
我们使用一个不相交的集合森林来实现算法。算法的时间可以分为两部分，一部分是是第0步排序，O(mlogm)，另一部分第1-3步，时间O(m<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\alpha(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>)，其中α是增长非常慢的逆阿克曼函数。两个集合的合并我们使用并查集，每条边最多有三个不相交的集合运算。如果我们知道Int和每个分量的大小，就可以在常数时间内完成每个边的MInt的计算。为一个子集维护Int可以在每次合并的恒定时间内完成，因为子集MST中的最大权重边缘就是导致合并的边缘。这是因为引理1意味着导致合并的边是被合并的两个集合之间的最小权重边。合并后的集合大小只是合并的两个子集大小的总和。<br>
#5、结果<br>
首先我们考虑单色（强度）图像的情况。彩色图像被处理为三个单独的单色图像，如下所述。与其他基于图的图像分割方法（例如[14,18,19]）一样，我们定义了一个无向图g=（V，e），其中每个图像像素pi都有一个对应的顶点vi∈V。边缘集E是通过连接8连通意义上的相邻像素对来构造的（可以使用任何其他局部邻域）。这将产生一个m=O（n）的图，因此对于n个图像像素，分割算法的运行时间是O（nlogn）。我们使用基于边缘连接的像素之间绝对强度差异的边缘权重函数，<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>I</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo><mo>−</mo><mi>I</mi><mo>(</mo><msub><mi>p</mi><mi>j</mi></msub><mo>)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">w((v_i, v_j)) = |I(p_i) - I(p_j)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">I(p_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>代表pi点像素值。通过我们会在计算边的权重前使用高斯模糊 来平滑图像，来消除数字化伪影。我们总是使用σ=0.8的高斯函数，它不会对图像产生任何可见的变化，但有助于去除伪影。<br>
对于彩色图像，我们运行该算法三次，分别针对红色、绿色和蓝色平面，然后将这三组分量相交。具体地说，当两个相邻像素出现在三个颜色平面分割的同一个分量中时，我们将它们放在同一个分量中。或者，我们可以在一个图上只运行一次该算法，其中边缘权值测量某个颜色空间中像素之间的距离，但是实验上，我们通过以刚才描述的方式对每个颜色平面的分段进行相交，获得了更好的结果。<br>
该算法有一个运行时参数，即用于计算阈值函数τ的k值。因此k有效地设置了一个观察范围，k越大，就越倾向于较大的成分。根据图像的分辨率以及细节在场景中的重要程度，我们在本节（以及整篇文章）中的示例使用了两种不同的参数设置。例如，在COIL数据库的128×128图像中，我们使用k=150。在320×240或更大的图像中，例如街道场景和棒球运动员，我们使用k=300。<br>
图2中的第一个图像显示了一个街道场景。注意，通往围栏的草坡有很大的变化。我们的算法正是为了处理这种可变性（回想一下图1中合成示例中的高可变性区域）。第二幅图像显示了分割，每个区域都被分配了一个随机颜色。算法发现的六个最大的组成部分是：围栏后面的三个草地区域、草地斜坡、货车和道路。左下角道路的缺失部分是彩色图像中一个明显不同的区域，从中可以计算出该分割（由于成像伪影造成的斑点）。注意，由于镜面反射，面包车的颜色也不统一，但这些反光效果很差，因此它们被视为内部变化，并合并到一个区域中。<br>
图3中的第一个图像显示了两个棒球运动员。 与前面的示例一样，这里的草丛区域变化很大。 由于布料上的褶皱，运动员的制服也有很大的差异。 第二张图片显示了分割。 该算法发现的六个最大组成部分是：后墙，大都会队徽，一个大草丛区域（包括顶部玩家下方的部分墙壁），两个玩家的制服中的每一个，以及第二个队员下方的一个小草丛 播放器。 较大的草丛区域包括墙壁的一部分，这是因为该区域的变化相对较大，并且草与墙壁之间的强度存在长期缓慢的变化（没有明显的边界证据）。 由于布的褶皱，该“边界”的大小与运动员制服内的边界类似。<br>
图4显示了室内场景图像的算法结果，其中细节和较大的结构在感知上都很重要。请注意，分割保留了小区域，例如人们佩戴的姓名标签和窗户后面的东西，同时为高可变性区域创建单个较大区域，例如靠近图像顶部的空调管道、衣服和家具。此图还显示，有时会发现一些小的“边界区域”，例如在夹克或衬衫的边缘。之所以会出现这样的狭窄区域，是因为在两个相邻区域的颜色和强度之间有一个或两个像素宽的区域。这在任何基于网格图的分割方法中都很常见。如果需要，可以通过去除颜色或强度接近相邻区域平均值的细长区域来消除这些区域。<br>
图5显示了COIL图像数据库中的三个简单对象。每个区域显示的是我们的算法找到的最大区域，它不是黑色背景的一部分。请注意，这些对象中的每一个在对象的面上都有一个很大的强度梯度，但是这些区域是正确分割的。这说明了算法设计用来处理的另一种情况，即由于光照而导致的强度缓慢变化。<br>
#6、最近邻图结果<br>
一种常见的图像分割方法是将每个像素映射到某个特征空间中的一个点，然后找到相似点的簇（例如[3,4,9]）。在本节中，我们将研究使用第4节中基于图的分割算法，以便找到类似点的聚类。在这种情况下，图G=（V，E）具有与每个特征点（每个像素）相对应的顶点，并且在特征空间中存在连接相邻的特征点vi和vj的边（vi，vj），而不是使用图像网格中的相邻像素。有几种可能的方法可以确定哪些特征点通过边连接。我们将每个点连接到固定数量的最近邻居。另一种可能性是使用固定距离d内的所有邻域。在任何情况下，最好避免考虑所有O（n2）对特征点。<br>
边缘的权重w（vi，vj）是特征空间中两个对应点之间的距离。对于这里展示的实验，我们将每个像素映射到特征点（x，y，r，g，b），其中（x，y）是像素在图像中的位置，（r，g，b）是像素的颜色值。我们使用点之间的L2（欧几里德）距离作为边缘权重，尽管其他距离函数也是可能的。<br>
内部差异度量Int（C）对特征空间中的点有一个相对简单的潜在直觉。它规定了将包含在C中的一组特征点连接到特征空间中的单个体积所需的最小膨胀半径。考虑用半径为r的球代替每个特征点。从MST的定义可以看出，只有当r≥Int（C）/2时，这些球的结合才会形成一个单一的连接体。组件之间的差异，Dif（C1，C2）也有一个简单的潜在直觉。它规定了将至少一个C1点连接到C2点所需的最小扩张半径。因此，我们的分割技术与[4]的工作密切相关，后者类似地采用了基于参数空间中扩张点的聚类方法（然而，它们首先使用我们没有执行的数据的新转换，然后使用固定的扩展半径，而不是我们使用的变量）。<br>
我们不是构造一个完整的图——所有的点都是彼此的邻居，而是为每个点找到一个小数目的邻居。这使得n个图像像素具有O（n）边，并且O（nlogn）时间分割方法的总运行时间。有许多可能的方法可以为每个点选择一个固定数量的邻居。我们使用ANN算法[1]来寻找每个点的最近邻。该算法在实际应用中速度相当快，给出了一个包含几十万个点的5维特征空间。人工神经网络方法还可以找到近似的最近邻，这比查找实际的最近邻更快。对于这里报告的示例，我们使用每个像素的十个最近邻来生成图形的边。<br>
与上一节（图像网格用于定义图形）的主要区别之一是，特征空间中最近的邻居捕捉到的图像在空间上更非局部属性。在网格图的情况下，图中的所有邻居都是图像中的邻居。在这里，点在图像中可能相距很远，但仍然是少数几个最近的相邻点（如果它们的颜色高度相似并且中间的图像像素具有不同的颜色）。例如，这可能导致分割图像中断开的区域，而在网格图的情况下不会发生这种情况。<br>
图6显示了来自[12]和[8]的合成图像及其分割，使用k=150且没有平滑处理（σ=0）。在这个例子中，空间上不相连的区域不会反映出有趣的场景结构，但是我们将在下面看到一些例子。<br>
对于本节中的其余示例，我们使用k=300和σ=0.8，如前一节所述。首先，我们注意到最近邻图产生的结果与网格图相似，在图像中感知显著区域在空间上是连接的。例如，在上一节中考虑的街道场景和棒球运动员场景使用最近邻图或网格图生成非常相似的分段，通过将图7中的结果与图2和图3中的结果进行比较可以看出这一点。<br>
图8显示了使用最近邻图的另外两个示例。这些结果是不可能实现的网格图方法，因为某些感兴趣的区域在空间上是不连通的。第一个例子展示了一个花圃，在这里红色花草在图像的前景中在空间上不相交，然后在背景中融合在一起。大多数这些花被合并到一个区域中，这是用网格图方法无法实现的。图8中的第二个示例显示了晚上的埃菲尔铁塔。亮黄色的光形成了一个空间上不相连的区域。这些例子表明，该分割方法与最近邻图的使用相结合，可以捕捉图像的高层次属性，同时保留感知上重要的区域边界。<br>
#7、总结<br>
本文介绍了一种新的基于成对区域比较的图像分割方法。我们已经证明，分割过粗或过细的概念可以用测量一对区域之间边界的证据的函数来定义。我们的分割算法可以做出简单的贪婪决策，但是根据特定的区域比较函数，生成的分割既不太粗糙也不太细的全局特性。对于m个图边，该方法在O（mlogm）时间内运行，并且在实践中运行速度也很快，一般只需几秒钟。<br>
我们使用的成对区域比较谓词考虑了两个区域之间的最小权重边缘来衡量它们之间的差异。因此，我们的算法将合并两个区域，即使它们之间有一个单一的低权重边缘。这并不像它最初出现的那样是一个问题，部分原因是该边缘权重仅与每个组件的最小生成树边缘进行比较。例如，第5节和第6节中考虑的例子说明了该方法能够捕获复杂图像的许多感知重要方面的分割。尽管如此，在确定没有证据表明两个地区之间存在边界之前，人们可以设想需要不止一个廉价连接的措施。解决这个问题的一种自然方法是使用分位数而不是最小边缘权重。然而，在这种情况下，找到一个既不太粗也不太细的细分是一个NP难题（如附录所示）。我们的算法是独一无二的，因为它不仅效率很高，而且能捕捉到图像的非局部特性。<br>
我们已经用两种不同的图形演示了我们的图像分割算法。第一种方法使用图像网格来定义图像像素之间的局部邻域，并测量每对邻域之间在强度（或颜色）上的差异。第二种方法将图像像素映射到特征空间中的点，该空间组合了（x，y）位置和（r，g，b）颜色值。图形中的边连接此要素空间中靠近的点。该算法在使用这两种图形时都能获得很好的结果，但后一种类型的图形可以更直观地捕捉图像的全局方面。<br>
图像分割仍然是一个具有挑战性的问题，然而，通过引入基于图的算法，我们开始取得实质性的进展，这些算法既有助于加深我们对问题的理解，也有助于提供有用的计算工具。这里报道的工作和标准化切割方法[14]只是这些最新进展的几个例子。<br>
——————————————————————————————————————————<br>
个人理解：<br>
论文里提出的图像分割方法是将整幅图看作一个无向图，每个像素点看作顶点，像素点之间的边有一个权重值，代表两个像素点的相异度(可以是灰度、梯度等)。先定义一个组内部的距离：最小生成树中所含边的最大权重w0，如果一个组。再定义组和组之间的距离：两个组之间有一些点有边相连，这些边中最小权值就是两个组的距离dif，如果没有边相连那么dif是正无穷。定义谓词D：如果dif &gt; min(w0 + t0, w1 + t1)(t0是一个阈值函数，用来控制相异程度)，那么就将两个组合并。<br>
算法：<br>
1. 对图中所有的边进行非递减排序。(O(mlogm)),m是边的个数<br>
2. 每个顶点各自为1组<br>
3. 如果两个组符合谓词D，就合并<br>
可以在处理之前对图像进行高斯模糊，论文中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>取0.8，认为它不会对图像产生任何可见的变化，但有助于去除伪影。<br>
<a href="http://cs.brown.edu/people/pfelzens/segment/segment.zip">原论文C++代码</a><br>
<a href="https://github.com/salaee/pegbis">基于Python代码</a> 代码的输出图像是0-255的float类型图像，不能正常显示，需要在main.py的80行加入 output /= 255.0归一化到0-1.0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selective Search for Object Recognition]]></title>
        <id>https://secrul.github.io/post/selective-search-for-object-recognition/</id>
        <link href="https://secrul.github.io/post/selective-search-for-object-recognition/">
        </link>
        <updated>2020-08-20T01:11:29.000Z</updated>
        <content type="html"><![CDATA[<p>#概论<br>
本文解决了图像识别中生成物体可能位置的问题。我们提出了选择性搜索，它结合了穷尽搜索和分割的优点。与分割类似，我们使用图像结构来指导采样过程，像穷尽搜索一样，我们的目标是捕获所有可能的目标位置。我们不再使用单一的技术来生成可能的目标位置，而是使搜索多样化，并使用各种互补的图像分割来处理尽可能多的图像条件。我们的选择性搜索结果是一个小集合的数据驱动，类无关，高质量的地点，产生99%的召回率和平均最佳重叠0.879在10097个地点。与穷尽搜索相比，位置的数量减少，因此可以使用更强的机器学习技术和更强的外观模型进行对象识别。在本文中，我们展示了我们的选择性搜索能够使用强大的词袋模型进行识别。选择性搜索软件是公开。<br>
#导论<br>
很长一段时间以来，人们都在识别物体之前先对其进行描述。这就产生了分割，它的目标是通过一个通用算法对图像进行独特的分割，在这个分割中每部分都对应着每个物体的轮廓。在分割这个问题上，过去很多年产生了大量的进展。但是图像本质上是层次化的，在图1a中，沙拉和勺子在沙拉碗里面，沙拉碗又在桌子上。此外，根据上下文，此图中的术语表可以仅指木材或包括表上的所有内容。因此，图像的性质和对象类别的不同用途都是分层的。这将禁止对所有对象进行唯一的分区，但大多数特定的用途除外。因此，对于大多数任务来说，在一个分割中使用多个尺度是必要的。这是最自然地通过使用层次划分来解决的，例如Arbelaez等人所做的那样。<br>
不仅仅分割应该是分层的，一个使用单一策略的通用分割方法也许不存在。为什么一个区域应该组合在一起有很多复杂的原因：在图1b中，可以使用颜色将猫分开，但是它们的纹理是相同的。相反，在图1c中，变色龙在颜色上与周围的叶子相似，但其质地不同。最后，在图1d中，车轮在颜色和质地上与汽车大不相同，但却被汽车包围着。因此，单个视觉特征不能解决分割的模糊性。<br>
最后，还有一个更根本的问题。具有非常不同特征的区域，例如毛衣上的一张脸，只有在确定手边的对象是人之后，才能将其组合成一个对象。因此，如果没有事先的识别，很难确定一张脸和一件毛衣是同一物体的一部分。<br>
这导致了与传统方法相反的结果：通过识别对象来进行定位。最近这种物体识别方法在不到十年的时间里取得了巨大的进步[8,12,16,35]。利用从示例中学习的外观模型，执行穷尽搜索，其中检查图像中的每个位置，以确保不会遗漏任何潜在的对象位置。<br>
但是，穷尽搜索本身有着几个缺点，搜索每一个可能的位置计算量太大，不可能实现。必须通过使用规则网格、固定比例和固定纵横比来减少搜索空间。在大多数情况下，搜索点的数量仍然很大，以至于需要实施其他限制。分类更简单，模型需要很快。此外，一个统一的抽样会产生很明显它们并不包含某个物体的方框。一个关键问题是：我们能否通过数据驱动的分析来指导抽样工作，而不是盲目地使用穷尽式搜索来进行抽样调查？<br>
在这篇文章中，我们的目的是结合分割和穷举搜索的优点，提出一种数据驱动的选择性搜索。受自底向上分割的启发，我们的目标是利用图像的结构来生成目标位置。受详尽搜索的启发，我们的目标是捕捉所有可能的物体位置。因此，我们的目标是使采样技术多样化，以尽可能多地考虑图像条件，而不是使用单一的采样技术。具体来说，我们使用基于数据驱动的分组策略，通过使用各种互补分组标准和具有不同不变性属性的各种互补颜色空间来增加多样性。位置集是通过组合这些互补分区的位置来获得的。我们的目标是生成一个独立于类的、数据驱动的、选择性的搜索策略，该策略可以生成一小组高质量的对象位置。<br>
选择性搜索的应用领域是目标识别。因此，我们对最常用的数据集进行评估，即Pascal VOC检测挑战，它由20个对象类组成。这个数据集的大小产生了选择性搜索的计算约束。此外，此数据集的使用意味着位置的质量主要是根据边界框来评估的。然而，我们的选择性搜索同样适用于区域，也适用于“草”等概念。<br>
本文提出了一种选择性搜索的目标识别方法。我们的主要研究问题是：<br>
（1）什么是好的分散策略，以适应分割作为选择性搜索策略？<br>
（2） 选择性搜索在图像中创建一小组高质量的位置有多有效？<br>
（3） 我们可以使用选择性搜索来使用更强大的分类器和外观模型来进行物体识别吗？<br>
#2、相关工作<br>
我们定义了与目标识别领域相关的工作，并将其分为三类：穷尽搜索、分割和其他不属于这两类的采样策略。<br>
##2、1穷尽搜索<br>
由于一个物体可以以任何大小定位在图像中的任何位置，所以很自然地用穷尽搜索[8,16,36]。然而，视觉搜索的空间是巨大的，使得穷尽式搜索的计算成本很高。这对每个地点的评估成本和/或考虑的地点数量施加了限制。因此，大多数滑动窗口技术使用粗糙的搜索网格和固定的纵横比，使用弱分类和经济图像特征，如HOG。这种方法通常被用作一系列分类器的预选步骤。<br>
与滑动窗口技术相关的是Felzenszwalb等人非常成功的基于零件的目标定位方法。他们的方法还使用SVM和HOG特征进行穷举搜索。然而，他们搜索对象或者对象部分，它们的组合会产生令人印象深刻的对象检测性能。<br>
Lampert等人提出用外观模型来指导搜索。这既减轻了使用常规网格、固定比例和固定纵横比的限制，同时也减少了访问地点的数量。这是通过使用分支定界技术在图像中直接搜索最佳窗口来完成的。虽然他们在线性分类器方面取得了令人印象深刻的结果，[1]发现对于非线性分类器，这种方法在实际应用中对每张图像的访问量仍然超过100000个窗口。<br>
我们提出了选择性搜索，而不是盲目的穷举搜索或分支定界搜索。我们使用底层图像结构来生成对象位置。与所讨论的方法不同，这会产生一个完全独立于类的位置集。此外，由于我们不使用固定的纵横比，我们的方法不仅限于对象，而且应该能够找到“草”和“沙”之类的东西（这也适用于[17]）。最后，我们希望生成更少的位置，这将使问题变得更容易，因为样本的可变性变得更低。更重要的是，它释放了计算能力，可用于更强大的机器学习技术和更强大的外观模型。<br>
##2.2分割<br>
我们提出了选择性搜索，而不是盲目的穷举搜索或分支定界搜索。我们使用底层图像结构来生成对象位置。与所讨论的方法不同，这会产生一个完全独立于类的位置集。此外，由于我们不使用固定的纵横比，我们的方法不仅限于对象，而且应该能够找到“草”和“沙”之类的东西（这也适用于[17]）。最后，我们希望生成更少的位置，这将使问题变得更容易，因为样本的可变性变得更低。更重要的是，它释放了计算能力，可用于更强大的机器学习技术和更强大的外观模型。<br>
我们提出了选择性搜索，而不是盲目的穷举搜索或分支定界搜索。我们使用底层图像结构来生成对象位置。与所讨论的方法不同，这会产生一个完全独立于类的位置集。此外，由于我们不使用固定的纵横比，我们的方法不仅限于对象，而且应该能够找到“草”和“沙”之类的东西（这也适用于[17]）。最后，我们希望生成更少的位置，这将使问题变得更容易，因为样本的可变性变得更低。更重要的是，它释放了计算能力，可用于更强大的机器学习技术和更强大的外观模型。<br>
##2.3其他采用策略<br>
Alexe等人通过建议搜索任何独立于类的对象来解决穷举搜索的采样空间大的问题。在他们的方法中，他们训练了一个分类的对象窗口，这些对象具有明确的形状（而不是像“草”和“沙”）。然后，他们不再进行全面彻底的搜索，而是随机抽取他们所应用的分类框的样本。具有最高“客观性”度量的方框充当一组对象假设。然后使用该集合极大地减少由类特定对象检测器评估的窗口数。我们把我们的方法和他们的工作作了比较。<br>
另一种策略是利用词袋模型中的视觉词来预测物体的位置。Vedaldi等人利用跳跃窗口[5]，学习单个视觉单词与目标位置之间的关系来预测新图像中的目标位置。Maji和Malik[23]将这些关系中的多个结合起来，使用Hough变换来预测对象的位置，然后在Hough最大值附近随机采样窗口。在课堂上，我们用独立的假设来对比学习对象的结构。<br>
总而言之，我们的新奇之处如下。我们使用分段作为选择性搜索，而不是穷尽搜索[8,12,16,36]，生成一小组独立于类的对象位置。与[4，9]的分割不同，我们没有关注最佳分割算法[3]，而是使用各种策略来处理尽可能多的图像条件，从而在可能精确地捕捉更多对象的同时，大大降低了计算成本。我们使用自底向上的分组过程来生成良好的对象位置，而不是学习随机采样的盒[2]上的对象度量。<br>
#3选择性搜索<br>
在这一节中，我们详细介绍了我们的选择性搜索算法的目标识别，并提出了多种多样的策略来处理尽可能多的图像条件。选择性搜索算法需要考虑以下设计因素：<br>
1. 捕获所有的大小方框：对象可以在图像中以任何大小尺度出现。此外，有些物体的边界比其他物体要模糊。因此，在选择性搜索中，必须考虑所有对象的比例，如图2所示。这是最自然地通过使用分层算法来实现的。<br>
2. 多元化：没有一个单一的最优策略将区域分组在一起。如图1所示，区域可能形成一个物体，仅仅是因为颜色，纹理，或者是因为部分被封闭。此外，光照条件，如阴影和光的颜色可能会影响区域如何形成一个对象。因此，我们希望有一套不同的策略来处理所有的情况，而不是一个在大多数情况下都有效的单一策略。<br>
3. 计算快速：选择性搜索的目标是生成一组可能的目标位置，以供在实际的对象识别框架中使用。这个集合的创建不应该成为一个计算瓶颈，因此我们的算法应该相当快。<br>
##3.1分层分组的选择性搜索<br>
我们的选择性搜索是基于一个分层分组算法。图像分割中大多采用自下向上的分组策略，我们也采用这个。因为整个分组过程是层次性，我们可以自然而然地在分组过程中找到所有尺度地方框。这满足要找到所有尺度和比例地方框的要求。<br>
由于图像中区域可以产生比像素更丰富的信息，因此我们希望尽可能使用基于区域的特征。为了得到一组理想情况下不跨越多个对象的小起始区域，我们使用了Felzenszwalb和Huttenlocher[13]的快速方法[3]发现非常适合于此目的。我们的分组过程如下所示。我们首先使用[13]创建初始区域。然后我们使用贪心算法迭代地将区域分组在一起：首先计算所有相邻区域之间的相似度。将两个最相似的区域组合在一起，并计算结果区域与其相邻区域之间的新相似性。重复分组最相似区域的过程，直到整个图像成为一个单独的区域。一般方法详见算法1。<br>
算法一：<br>
<strong>输入：(彩色)图像</strong><br>
<strong>输出：一系列可能的物体位置</strong><br>
<strong>通过Felzenszwalb方法获得一些初始区域R={r1,r2,r3......}</strong><br>
<strong>初始化相似集合S = 空</strong><br>
<strong>计算所有相邻区域对ri,rj的相似性度量s(ri,rj)，并加入到S集合</strong><br>
<strong>如果S集合不为空</strong><br>
<strong>获取S集合中的最相似的临近区域对s(ri,rj)，合并区域ri,rj为rt，rt加入集合R</strong><br>
<strong>从S集合中去除所有关于ri的相似性度量，去除所有关于rj的相似性度量</strong><br>
<strong>计算关于rt关于所有临近区域的相似性度量s(rt, ra)，并加入集合S</strong><br>
对于区域ri和rj之间的相似性s（ri，rj），我们需要在计算速度快的约束下使用多种互补测度。实际上，这意味着相似性应该基于可以通过层次结构传播的特征，即在将区域ri和rj合并为rt时，区域rt的特征需要从ri和rj的特征计算出来，而不需要访问图像像素。<br>
##3.2多样性策略<br>
选择搜索的第二个设计准则是使抽样多样化，并创建一组互补策略，这些策略的位置随后被组合在一起。我们使我们的选择性搜索多样化：（1）使用具有不同不变性属性的各种颜色空间；（2）使用不同的相似性度量sij；（3）通过改变起始区域<br>
1. 多样的颜色空间：我们要考虑不同的场景和照明条件。因此，我们在具有一系列不变性的颜色空间中执行我们的分层分组算法。具体地说，我们使用以下不变度增加的颜色空间：（1）RGB，（2）强度（灰度图像）I，（3）Lab，（4）归一化RGB的rg通道加上表示为rgI的强度，（5）HSV，（6）表示为RGB的归一化RGB，（7）C[14]这是一个划分强度的对手颜色空间，最后（8）来自HSV的色调通道H。表1列出了具体的不变性特性。当然，对于黑白图像，颜色空间的变化对算法的最终结果几乎没有影响。对于这些图像，我们依靠其他分散方法来确保良好的目标位置。在本文中，我们在整个算法中始终使用单一颜色空间，这意味着[13]中的初始分组算法和我们随后的分组算法都是在这个颜色空间中执行的。<br>
2. 多样的相似性度量：我们定义了四个互补的、快速计算的相似性度量。这些度量值都在[0,1]范围内，这有助于这些度量值的组合。<br>
<strong>颜色</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">S_{color}(r_i,r_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,度量颜色的相似性，具体说，对于每个区域的每个颜色通道，我们得到一个包含25个柱子的一维直方图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mo>{</mo><mrow><msubsup><mi>c</mi><mi>i</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>c</mi><mi>i</mi><mn>2</mn></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msup><mi>c</mi><mn>2</mn></msup><msub><mn>5</mn><mi>i</mi></msub></mrow><mo>}</mo></mrow><annotation encoding="application/x-tex">C_i = \{{c^1_i, c^2_i,.....c^25_i}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mopen">{</span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，当时RGB三通道每个区域就是75个柱子.颜色直方图用L1正则化进行归一化，相似性度量可以用下面公式表示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msubsup><mi>c</mi><mi>i</mi><mi>k</mi></msubsup><mo separator="true">,</mo><msubsup><mi>c</mi><mi>j</mi><mi>k</mi></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">s_{color}(r_i,r_j) =  \sum _{k=1}^n min(c_i^k, c_j^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.394772em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
合并后区域rt的颜色直方图用下图计算:<br>
<img src="https://secrul.github.io/post-images/1598100440428.png" alt="" loading="lazy"><br>
区域rt的大小就是区域ri和rj大小之和<br>
<strong>纹理</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">S_{texture}(r_i,r_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：我们使用类似SIFT的快速测量来表示纹理，因为SIFT本身对于材料识别非常有效[20]。我们对每个颜色通道使用σ=1在八个方向上取高斯导数。对于每个颜色通道的每个方向，我们使用10的bin大小提取直方图。这导致当使用三个颜色通道时，每个区域ri的纹理直方图Ti={t1 i，···，tn i}，维数n=240。纹理直方图使用L1标准化。使用直方图交集测量相似度：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msubsup><mi>c</mi><mi>i</mi><mi>k</mi></msubsup><mo separator="true">,</mo><msubsup><mi>c</mi><mi>j</mi><mi>k</mi></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">s_{texture}(r_i,r_j) =  \sum _{k=1}^n min(c_i^k, c_j^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.394772em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
<strong>大小尺度</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">S_{size}(r_i,r_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>鼓励小尺度的区域早点合并。这迫使S中的区域，即尚未合并的区域，在整个算法中具有相似的大小。这是可取的，因为它可以确保在图像的所有部分创建所有比例的对象位置。例如，它可以防止一个地区一个接一个地吞噬所有其他地区，只在这个增长地区的位置产生所有规模，而没有其他地方。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mi mathvariant="normal">（</mi><mi>r</mi><mi>i</mi><mi mathvariant="normal">，</mi><mi>r</mi><mi>j</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">s_{size}（ri，rj）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">）</span></span></span></span>定义为ri和rj共同占据的图像的分数：<br>
<img src="https://secrul.github.io/post-images/1598100448148.png" alt="" loading="lazy"><br>
size代表区域内像素点个数<br>
<strong>重合</strong>衡量区域ri和rj的相互融合程度。这个想法是为了填补空白：如果ri包含在rj中，为了避免任何漏洞，首先合并这些是合乎逻辑的。另一方面，如果ri和rj几乎不接触，它们很可能形成一个奇怪的区域，不应该合并。为了使度量保持快速，我们只使用区域和包含框的大小。具体而言，我们将BBij定义为围绕ri和rj的紧密边界框。现在s fill（ri，rj）是包含在BBij中的图像的分数，它不被ri和rj区域覆盖：<br>
<img src="https://secrul.github.io/post-images/1598100453807.png" alt="" loading="lazy"><br>
请注意，通过跟踪每个区域周围的边界框，可以有效地计算此度量，因为两个区域周围的边界框可以很容易地从中导出。<br>
在本篇文章中，最终的相似性度量是上述四个的结合：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>s</mi><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>s</mi><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><mo>∗</mo><msub><mi>s</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mn>4</mn></msub><mo>∗</mo><msub><mi>s</mi><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>l</mi></mrow></msub><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">s(r_i,r_j) = a_1*s_{color}(r_i,r_j) + a_2 * s_{texture}(r_i,r_j) + a_3 * s_{size}(r_i,r_j) + a_4 * s_{fill}(r_i,r_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
其中ai∈{0,1}表示是否使用相似性度量。由于我们的目标是使我们的策略多样化，我们不考虑任何加权的相似性。<br>
3. 初始区域多样化：第三种多元化策略是改变互补的起始区域。据我们所知，方法[13]是最快的，公开的算法，产生高质量的起始位置。我们找不到任何其他具有类似计算效率的算法，所以在本文中我们只使用了这种过度分段。但是请注意，不同的起始区域（已经）通过改变颜色空间得到，每个颜色空间具有不同的不变性属性。另外，我们改变了[13]中的阈值参数k。<br>
##3.3预测位置综合<br>
在本文中，我们结合了我们的分层分组算法的几种变体的目标假设。理想情况下，我们希望以这样一种方式排序对象假设，即最有可能成为对象的位置首先出现。这使得人们能够根据后续特征提取和分类方法的计算效率，在结果对象假设集的质量和数量之间找到一个良好的折衷。我们选择根据每个单独分组策略中产生假设的顺序对组合对象假设集进行排序。然而，由于我们综合了多达80种不同战略的结果，这样的秩序过于强调大区域。为了防止这种情况的发生，我们将随机性包括在下面。给定一个分组策略j，设rj i为在层次结构中的位置i处创建的区域，其中i=1表示层次结构的顶部（其对应的区域覆盖整个图像）。我们现在计算位置值vj i为RND×i，其中RND是范围[0,1]内的随机数。最终排名是通过使用vj i对地区进行排序得到的。当我们根据边界框使用位置时，我们首先对所有位置进行排名，如上文所述。只有在这之后，我们才过滤掉排名较低的重复项。这确保了重复的盒子有更好的机会获得高排名。这是可取的，因为如果多个分组策略建议相同的框位置，那么它很可能来自图像的视觉一致部分。<br>
#4.使用选择性搜索进行目前识别<br>
本文利用我们的选择性搜索产生的位置来进行目标识别。本节详细介绍了我们的对象识别框架。两种类型的特征在物体识别中占主导地位：定向梯度直方图（HOG）[8]和单词包[7,27]。Felzenszwalb等人已经证明HOG与基于零件的模型相结合是成功的。[12] 一。然而，由于它们使用穷尽搜索，HOG特征与线性分类器相结合从计算角度来看是唯一可行的选择。相比之下，我们的选择性搜索允许使用更昂贵和更强大的功能。所以我们用词包来识别物体[16，17，34]。然而，我们使用了比[16，17，34]更强大（和更昂贵）的实现，通过使用各种颜色筛选描述符[32]和更精细的空间金字塔划分[18]。具体来说，我们在单个尺度上对每个像素的描述符进行采样（σ=1.2）。利用文献[32]中的软件，我们提取了SIFT[21]和两个对检测图像结构最敏感的颜色筛，扩展对位偏移[31]和RGBSIFT[32]。我们使用一个尺寸为4000的可视码本和一个4层的空间金字塔，使用1x1、2x2、3x3。以及4x4分区。这使得特征向量的总长度为360000。在图像分类中，已经使用了这种大小的特征[25，37]。由于空间金字塔比构成HOG描述子的单元产生更粗糙的空间细分，因此我们的特征包含的关于对象特定空间布局的信息较少。因此，HOG更适合于刚性对象，而我们的特征更适合于可变形对象类型。作为分类，我们使用Shogun工具箱[28]使用直方图交集核的支持向量机[28]。为了应用训练有素的分类器，我们使用了[22]的快速近似分类策略，在[30]中，该策略对单词包非常有效。我们的培训程序如图3所示。初始的正例子由所有地面真实物体窗口组成。作为最初的否定例子，我们从所有的对象位置选择我们的选择性搜索，有20%到50%的重叠与一个积极的例子。为了避免近乎重复的反面示例，如果一个负数与另一个负数重叠超过70%，则将其排除在外。为了使每堂课的初始负片数保持在20000以下，我们随机将汽车、猫、狗和人这几个类的底片减半。直观地说，这组例子可以被看作是接近正面例子的困难的否定。这意味着它们接近决策边界，因此，即使考虑到全套否定，它们也可能成为支持向量。事实上，我们发现，这些训练示例的选择提供了相当好的初始分类模型。然后我们进入一个再训练阶段，迭代地添加硬的否定例子（例如[12]）：我们使用我们的选择性搜索生成的位置将所学习的模型应用于训练集。对于每张底片，我们加上得分最高的位置。由于我们的初始训练集已经产生了好的模型，我们的模型只在两次迭代中收敛。对于测试集，最终模型适用于我们选择性搜索生成的所有位置。窗口按分类分数排序，而与较高评分窗口重叠超过30%的窗口被视为接近重复项并被删除。<br>
<a href="https://github.com/AlpacaDB/selectivesearch">python代码</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[目标检测-YOLOV1]]></title>
        <id>https://secrul.github.io/post/mu-biao-jian-ce-yolov1/</id>
        <link href="https://secrul.github.io/post/mu-biao-jian-ce-yolov1/">
        </link>
        <updated>2020-08-19T10:25:19.000Z</updated>
        <content type="html"><![CDATA[<p>#概要：<br>
我们提出了YOLO，一种新的物体检测算法。以前的物体检测都是用分类器来检测，相反，我们将物体检测看作为一个空间分割边界框和相关类概率的回归问题，单个的神经元网络在一次评估中直接从整幅图像中预测边界框和类的概率。因为整个检测过程只有一个网络，在检测性能上可以优化为端到端的。<br>
我们的架构极其快，基础版的YOLO模型可以实时处理图像，速度达到每秒45帧。一个简化版的快速YOLO处理速度可以达到惊人的155帧，并且mAP是其他实时物体检测模型的两倍。与目前最优异的物体检测模型相比，YOLO对物体的定位比较差，但会更少地预测出假阳物体。最后，YOLO是学习了物体地一般表现形式，当从自然图像推广到其他领域如艺术时，比其他的模型优异，包括DPM和R-CNN。<br>
#导论：<br>
人瞥一眼图片就马上知道图片上有什么，它们在哪个位置，它们之间如何互动的。人类的视觉系统很快并且很准，能够让我们完成一些复杂的任务，如无意识地开车。更快，更准确的物体检测算法可以让计算机不需要特别的传感器来开车，一些辅助设备传递更近实时的场景信息给用户，解锁更加一般的、响应式机器人系统。<br>
当前的物体检测系统使用分类器来检测，为了检测物体，系统就用一个分类器在测试图像上 的不同位置来匹配不同大小的对应物体。像DPM模型用一个滑动窗口在整幅图像上均匀来分类。<br>
最近的一些方法，如R-CNN使用“候选框”的方法先在图像上生成可能的分类框，然后对这些候选框进行分类。分完类后，一些处理方法用来去除重复的分类框，然后对于每个分类框进行打分。这些复杂的流程很慢，并且难以优化，因为每个独立的部分都要单独训练。<br>
我们将物体检测任务看作一个回归问题，直接从图像像素得到分类框的坐标还有类别的可能性。使用我们的方法，只需要看图像一次就知道有什么物体，它们在哪里。<br>
YOLO非常得快，参考图1，一个简单的卷积网络，<br>
在YOLOV1之前，物体检测都是分为两个阶段，如R-CNN。第一阶段，生成一些候选区，第二阶段对这些候选区进行分析，去除不合格的选区，对剩下的选区分类。而YOLO只有一个阶段，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[目标检测——R-CNN]]></title>
        <id>https://secrul.github.io/post/mu-biao-jian-ce-r-cnn/</id>
        <link href="https://secrul.github.io/post/mu-biao-jian-ce-r-cnn/">
        </link>
        <updated>2020-08-19T10:22:40.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>基于selective search方法选择出2000个候选框</li>
<li>对2000个候选框Resize为固定大小，分别用CNN提取一个特征向量，因为候选框重叠，所以很多重复计算</li>
<li>利用SVM对2000个特征向量进行分类打分</li>
<li>利用阈值函数去除较低的分，然后NMS进行分类</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RNN、LSTM]]></title>
        <id>https://secrul.github.io/post/rnnlstm/</id>
        <link href="https://secrul.github.io/post/rnnlstm/">
        </link>
        <updated>2020-08-16T11:04:45.000Z</updated>
        <content type="html"><![CDATA[<p>入门博客：<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">Andrej Karpathy blog</a>、<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a><br>
相关paper：<a href="https://www.bioinf.jku.at/publications/older/2604.pdf">LSTM</a>、 <a href="https://pan.baidu.com/s/1bUC_gOr-fnCkBrhBOZB7Wg">RNN经典论文</a> 提取码: wbbs<br>
传统的卷积网络如下：<br>
<img src="https://secrul.github.io/post-images/1597593103124.jpg" alt="" loading="lazy"><br>
虽然性能不错，但是面对视频、语音等有先后的序列数据时，不能很好地利用其内在地规律。例如在翻译时为了利用前面地语境来帮助后面单词的翻译，自然而然的就会想到将前面网络提取的特征传递到后面翻译的网络。但是这样子的话网络的层数不确定，于是引入循环结构。<br>
<img src="https://secrul.github.io/post-images/1597593959440.jpg" alt="" loading="lazy"><br>
为了便于理解，我们将循环结构展开：<br>
<img src="https://secrul.github.io/post-images/1597595618949.png" alt="" loading="lazy"><br>
这里循环的次数是一个超参数，time_steps由用户指定。<br>
h1的计算公式如下：<br>
<img src="https://secrul.github.io/post-images/1597596034281.png" alt="" loading="lazy"><br>
同理可以计算h2-h4，因为是循环结构，这里的参数都是贡献的<br>
<img src="https://secrul.github.io/post-images/1597596084740.png" alt="" loading="lazy"><br>
然后计算输出值y1：<br>
<img src="https://secrul.github.io/post-images/1597596123454.png" alt="" loading="lazy"><br>
同样由于循环结构，参数贡献，每次更新的是同一个参数<br>
<img src="https://secrul.github.io/post-images/1597596169436.png" alt="" loading="lazy"><br>
以y4为例，进行梯度下降法后向传播：<br>
<img src="https://secrul.github.io/post-images/1597596217922.png" alt="" loading="lazy"><br>
如果每个因子都小于0，那么乘积会很接近于0，代表x1对于y4的贡献基本为0，y4也就忘记x1的存在。这也是RNN的一个致命缺点，可以参考这篇论文来理解。[梯度消失与梯度爆炸](On the difficulty of training recurrent neural networks)<br>
虽然采取了截断等措施，但是效果不太好。知道LSTM的提出。<br>
LSTM的思想就是忘记一些不重要的数据，来减少后向传播链的长度。<br>
<img src="https://secrul.github.io/post-images/1597596460812.png" alt="" loading="lazy">、<br>
引入了三个门，遗忘门、输入门、输出门。<br>
<img src="https://secrul.github.io/post-images/1597596494582.png" alt="" loading="lazy"><br>
遗忘门会评价前一个模块的输出特征和本次输入的相关程度，决定遗忘的程度，1代表完全记住，0代表完全遗忘。<br>
<img src="https://secrul.github.io/post-images/1597596584385.png" alt="" loading="lazy"><br>
输入门评估改block产生状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">C_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的可信程度<br>
<img src="https://secrul.github.io/post-images/1597596689952.png" alt="" loading="lazy"><br>
上次的状态和本次产生的状态加权后作为本次所产生的输出状态。<br>
<img src="https://secrul.github.io/post-images/1597596753452.png" alt="" loading="lazy"><br>
输出门会评估告诉下一个模块的信息量。<br>
虽然LSTM可以忘记一些不重要的数据，但是当time_steps超过300的时候还是会出现梯度消失和梯度爆炸的蛮烦。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图像特征优化]]></title>
        <id>https://secrul.github.io/post/tu-xiang-te-zheng-you-hua/</id>
        <link href="https://secrul.github.io/post/tu-xiang-te-zheng-you-hua/">
        </link>
        <updated>2020-08-11T15:54:02.000Z</updated>
        <content type="html"><![CDATA[<p>##概述<br>
图像特征优化是指从含有大量冗余信息的原始特征中选择出具有代表性的特征子集的过程。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>m</mi><mi>x</mi><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>A</mi><mrow><mi>m</mi><mi>x</mi><mi>n</mi></mrow></msub><msub><mi>x</mi><mrow><mi>n</mi><mi>x</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">y_{mx1} = A_{mxn}x_{nx1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">x</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">x</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>x是原始m维数据，y是经过优化后的特征数据。找到合适的变换矩阵A，不丢失特征信息又能去除冗余。</p>
<ol>
<li>直接选择法：依据专家的经验和相关数学分析，在满足可分离性判据值最大的前提下，直接从原始数据中选取一组子集。</li>
<li>间接变换法：通过建立某种特定的映射关系，将高维的原始特征映射到低维的特征空间中。</li>
</ol>
<h2 id="基于选择的特征优化">基于选择的特征优化</h2>
<p>包括子集生成、子集评价、停止准则、  结果验证四个步骤。</p>
<ol>
<li>子集生成：基于某种搜索策略生成所需的特征子集</li>
<li>子集评价：依据评判准则对每一个候选特征子集评价，并于前一个最优子集比较，二者取更有的子集</li>
<li>停止准则：当特征子集满足要求时停止选择</li>
<li>结果验证：依据先验知识对特征子集进行验证<br>
可分离性判据：最优子集的评判准则。</li>
<li>类内\类间距离：根据类内距离小，类间距离大的特点采用 反应距离的函数</li>
<li>基于概率分布：散度越大，分类错误率越小，采用度量类间概率分布不一致的散度进行判定</li>
<li>基于熵函数：熵越小，划分越准确<br>
搜索选择策略：全局最优、局部次优</li>
<li>分支定界法：</li>
<li>序列前向选择法：已经挑选子集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,未被选元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>x</mi><mn>2......</mn></mrow><annotation encoding="application/x-tex">x_1,x2......</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>,选出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>J</mi><mi>D</mi></msub><mo>(</mo><msub><mi>x</mi><mi>k</mi></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">max(J_D(x_k + x_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>选择对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>加入集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>序列后向选择法：从集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中每次尝试删除一个元素使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>J</mi><mi>D</mi></msub><mo>(</mo><msub><mi>x</mi><mi>k</mi></msub><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">max(J_D(x_k - x_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>最大<br>
基于遗传算法的特征选择：<br>
##基于统计分析的特征优化<br>
###1.主成分分析：<br>
基本思想是保留大方差变量，利用线性 变换投影，去除小方差变量，达到压缩数据的目的，尽量减少丢失的额信息。<br>
###2.独立分量分析<br>
###3.线性判别分析<br>
###4.多维尺度分析<br>
##基于流形学习的特征优化<br>
非线性降维。我所理解的流行是三维空间中的立体平面-球面，以及更高维空间中低维分布。比如球面可以用三维坐标表示一个点，但是有很大的冗余，可以用二维坐标来表示(经度、纬度)。就可以进行数据空间的降维。<br>
<strong>核主成分分析</strong><br>
非线性的核映射技术，核主成分分析(KPCA)即在PCA的基础上增了核映射技术。</li>
<li>首先将观测空间中的数据映射到高维特征空间</li>
<li>然后再高维特征空间对数据进行线性PCA，对于观测空间就是非线性PCA<br>
<strong>局部线性嵌入</strong><br>
试图寻找样本点之间内在的拓扑结构，将样本点从观测空间映射到高维特征空间，并保持样本点之间的局部相似性。基于一个重要假设：高维空间数据集映射到低维空间，得到的嵌入流形在局部是线性的，确保了图像数据从高维空间向低维空间映射的局部保形性。用线性结构去近似非线性结构的局部特征，从而将非线性降维分解为局部的线性降维。</li>
</ol>
]]></content>
    </entry>
</feed>