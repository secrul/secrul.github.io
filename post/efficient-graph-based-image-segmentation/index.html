<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Eﬃcient Graph-Based Image Segmentation | secrul</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://secrul.github.io/favicon.ico?v=1600838194466">
<link rel="stylesheet" href="https://secrul.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="#概要
本篇文章解决了图像分割得问题。我们定义了一个谓词，它基于图像的图表示来度量两个区域的边界。我们基于这个谓词提出了一个高效图像分割算法，并且尽管这个算法是贪心的，但是分割结果也满足一些全局属性。我们应用这个算法来分割，使用两种不同局部..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://secrul.github.io">
        <img src="https://secrul.github.io/images/avatar.png?v=1600838194466" class="site-logo">
        <h1 class="site-title">secrul</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            文章
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/secrul" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      &copy 2020 by secrul. All rights reserved. | <a class="rss" href="https://secrul.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Eﬃcient Graph-Based Image Segmentation</h2>
            <div class="post-date">2020-08-20</div>
            
            <div class="post-content" v-pre>
              <p>#概要<br>
本篇文章解决了图像分割得问题。我们定义了一个谓词，它基于图像的图表示来度量两个区域的边界。我们基于这个谓词提出了一个高效图像分割算法，并且尽管这个算法是贪心的，但是分割结果也满足一些全局属性。我们应用这个算法来分割，使用两种不同局部邻域构造方法，并分别在真实图像和合成图像上展示效果。这个算法的时间复杂度基本上是关于图中边数目的线性时间，在实际中很快。该方法的一个重要特点是能够在低可变性图像区域保留细节，而在高可变性区域忽略细节。<br>
#导论<br>
图像分割和分组任务对于计算机视觉来说仍然是一个很大的挑战。自从格式塔心理学提出后，人类视觉感知中的“完整性感知”就被熟知。原则上，大量的计算视觉问题可以很好地利用分割后的图像，只要这些分割是可靠和高效的。例如，中级视觉问题，如立体和运动估计，需要一个适当的区域来支持对应操作。对于空间上不支持上述任务的区域可以先用分割技术来处理。更高层次的问题，如识别和图像索引，也可以利用分割结果进行匹配，以解决诸如语义分割与识别任务。(ﬁgure-ground指格式塔心理学的一个表现形式，https://en.wikipedia.org/wiki/Figure%E2%80%93ground_(perception))<br>
我们的目标是开发一种广泛使用的图像分割计算方法，其使用方式与在许多计算机视觉任务中使用的其他低级技术（例如边缘检测）的方式非常相似。 为了实现如此广泛的用途，我们认为分割方法必须具有以下属性，这一点很重要：<br>
1. 捕捕捉感知上重要的分组或区域，这些区域通常反映图像的全局方面。两个中心问题是提供对感知上重要的东西的精确描述，以及能够指定给定分割技术的作用。我们认为，为了更好地理解该方法并促进不同方法的比较，应精确定义结果分割的属性。<br>
2. 效率高，运行时间与图像像素数几乎成线性关系。为了实际应用，我们认为分割方法应该以类似于边缘检测或其他低级视觉处理技术的速度运行，这意味着时间几乎是线性的，并且具有低常数因子。例如，以每秒几帧的速度运行的分割技术可用于视频处理应用程序。<br>
在过去的几年中，有很多的基于特征向量的分割方法，这些方法太慢了，不能实际使用。相反，本篇论文中描述的方法可以用于大规模图片数据集。也有一些其他高效的图像分割方法，然后这些方法都不能捕捉像下方这幅图像的非局部感知信息。我们所提出的分割技术既能捕获一些重要的感知非局部特性，计算也很高效，可以达到O(nlgn)，可以用于视频分割。<br>
和一些典型的聚类方法一样，我们的方法从一个无向图模型中选择边。模型中节点代表图像的像素点。每一个边的权值代表两个端节点的相异程度。然而不向典型的方法，我们的方法基于图像邻域的多项程度，自适应地调整分割标准。这就产生了一种方法，在做出贪婪决策时，可以证明符合某些不明显的全局属性。我们还表明，其他与本文提出的自适应准则密切相关的自适应准则会导致计算困难（NP-hard）的问题。<br>
我们现在使用一个简单地合成图来说明我们地分割方法所捕获的非局部特征。看到图1中左上角的图片，很多人会认为这幅图包含三个部分，左边是一个灰度递增的矩形，右边是一个均匀灰度的矩形，其中包含了一个灰度变换很大的矩形。这个例子展示了我们认为一个分割方法应该捕获的感知上的重要属性。首先，灰度变化很大的区域不应该划分为多个区块。左边递增区域和右边中心区域灰度值变化都很大，因此，不能假定这些区域有稳定或变化很慢的灰度。<br>
图1所说明的另一个感知上重要的方面是这三个有意义的区域并不能 仅仅使用局部评判准则来识别。这是因为左边灰度递增区域和右边恒定区域的边界差异实际上要比右侧灰度变化剧烈区域的差异要小。因此为了分割这样的图像，必须使用非局部自适应算法。<br>
我们在3.1节提出的方法通过比较两个量来评判两个区域之间是不是有边界。第一个是边界两边的灰度值差异，第二个是每个区域内相邻像素之间的灰度差异。直觉上，如果两个区域之间的强度差异相对于至少一个区域内的强度差异较大，则在感知上很重要。我们基于这个思路提出了一个简单的算法。图1中剩余的三幅图像分别是我们算法的分割效果。尽管我们的算法是基于贪心策略，但它也能识别一些源于底层的全局属性，这点可以从图1中看出来。并且我们的方法在320x240的图像上运行时间也很短。<br>
本篇论文的结构如下，在下一章我们会讨论一些相关的工作，包括经典的分割公式和最近的基于图的方法。我们思考一个图像分割问题中特殊的基于图的公式，并定义了一个成对区域比较谓词。在第四节，我们提出基于这个谓词的高效的图像分割算法，并推导出一些它所遵循的全局属性，尽管它是贪心的。在第5节中，我们展示了一些图像的结果，这些图像使用图像网格来构建图像数据的基于图形的表示。然后在第6节中，我们使用更一般的图来说明该方法，但其中边的数量相对于像素点数目仍然是线性的。使用后一种方法产生的结果可以捕捉高级场景属性，例如将底层提取为单个区域，同时仍保留图像其他部分的细节。在附录中，我们展示了在第3节中提出的区域比较谓词的直接推广使得找到一个好的分割NP困难的问题。<br>
#2、相关工作<br>
30年来，有很多关于分割和聚类的文献，这些不仅仅局限于计算机视觉领域。在这一章，我们简短的介绍一些和我们方法最相关工作：早期基于图的方法、区域合并技术、基于将图像像素映射到某些特征空间的技术、最近的图像切割公式以及光谱方法。<br>
基于图的图像分割技术通常用图G=（V，E）表示，其中每个节点vi∈V对应于图像中的一个像素，E中的边缘连接若干对相邻像素。每个边都有一个权重，代表两端像素点某个属性(如如灰度)的关系。根据方法的不同，没对顶点之间可能存在一条边，可能也没有。早期的图像分割方向使用固定的阈值和局部度量，Zahn的方法基于最小生成树，这个方法被应用于图像分割和像素点聚类。对于图像分割技术，边的权值是像素点灰度值的差异，但对于点聚类权值是像素点之间的距离。<br>
Zahn方法的分割准则就是断开最小生成树上最大的边来进行分割。但是可以从图1中看出粗暴断开最大边的不足。如引言中所述，高可变性区域内像素之间的差异可能大于渐变区域和恒定区域之间的差异。因此，根据阈值，简单地断开大的权重边缘将导致高可变性区域被分割成多个区域，或者将渐变和恒定区域合并在一起。Urquhart[15]提出的算法试图解决这一缺点，通过使用与边缘接触的顶点的最小权重来规范化边的权重。然而，当应用于图像分割问题时，这还不足以提供一个合理的自适应分割准则。<br>
早期的另一种图像分割的思路是先分割然后按照一定的标准进行合并。一般来说，一致性准则对于整个子集都使用。例如，一个一致性谓词U(A)对于A集合为真，那么对于所有的A的子集B来说，该谓词U(B)全为真。通常这样的标准都是一致的灰度或者一致的梯度。由于高变化区域的存在，迄今为止提出的区域一致性准则不能用于正确分割图1中的示例。这个区域要么被分割成碎片，要么与周围的区域合并。<br>
很多的分割方法通过在一个特征空间找到一个聚类标准。这些方法通常假定图像是分段的常数，因为在某些特征空间中搜索所有接近的像素隐含地要求像素相似（例如，相似的颜色）。最近一种使用特征空间聚类的技术首先通过平滑数据以保持区域之间的边界来变换数据。这种平滑操作的总体效果是使同一簇内的点更近。这个方法通过将每个点用固定的半径膨胀为超球体，然后找这些超球体的相交部分来聚类。这个聚类的技术并不要求同一类中的点在固定距离以内。这个技术很接近我们要在3.1节介绍的区域比较谓语，只是我们所提出的方法是自调节选择一个合适的膨胀半径。<br>
最后，我们认为图像分割是基于寻找图的最小割集，最小化类别之间的相似性。Wu和Leahy介绍一个一个分割标准，但它偏向于发现小区域。这种偏差通过Shi和Malik[14]提出的归一化切割准则来解决，该准则考虑了区域的自相似性。与早期的基于图的分割方法相比，这些基于切割的分割方法捕捉了图像的非局部特性。然而，它们只提供了每个切割的特征，而不是最终分割的特征。<br>
归一化切割准则相比与以往的方法不管是理论上还是实际应用中都有一个重要的进步——最后分割结果直观上抓住了最显著的部分。但是归一化切割也是一个NP难问题。虽然Shi和Malik提出了计算最小归一化切割的近似方法，但这些近似中的误差并没有得到很好的解释。在实践中，这些近似值仍然很难计算，使得该方法用于相对较小的图像，对于大图像需要几分钟的计算时间。最近，Weiss[16]展示了Shi和Malik提出的基于特征向量的近似与图上更标准的谱划分方法的关系。然而，所有这些方法对于许多实际应用来说都太慢了。<br>
图切割方法的另一种替代是在嵌入图像平面的图中寻找循环。例如在[10]中，每个循环的质量都是以一种与标准化切割方法密切相关的方式规范化的。<br>
#3、基于图的分割<br>
我们提出一种基于图的分割方法。G=(V, E)，代表无向图，V是顶点集，E是边集，我们对顶点集V进行划分。每一个边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">E_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都有一个非负权重,W(E_{ij})代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>两个端点的相异度。在第5节和第6节中，我们考虑了用于图像分割的特殊边缘集和权重函数。然而，这里的公式与这些定义无关。<br>
在基于图的分割方法中，一个分割S是对顶点集V元素的子集划分，每一个子集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>(</mo><mi>C</mi><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">G&#x27; = (C, E&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，C是V的子集，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">E&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>也是E的子集。有很多种方法一个 分割的质量，但大体上我们希望同一个子集中元素更接近，不同子集元素差别更大。意味着同一子集的顶点之间的边的权值应该尽量小，不同子集顶点之间边的权值尽量大。<br>
##3.1、成对区域比较谓词<br>
在这一部分我们提出了一个谓词D，评判两个部分之间是否存在一个边界。该谓词将边界两边集合元素之间的差异性和两个部分内部每个相邻元素之间的差异性相比较。谓词将子集间差异与子集内差异进行比较，从而根据数据的局部特征进行自适应。<br>
我们定义子集C(C<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⫅</mo></mrow><annotation encoding="application/x-tex">\subseteqq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mrel amsrm">⫅</span></span></span></span>V)的内部差异是最小生成树里的最大权重。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>e</mi><mo>⫅</mo><mi>M</mi><mi>S</mi><mi>T</mi><mo>(</mo><mi>C</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow></msub><mi>w</mi><mo>(</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Int(C) = max_{e\subseteqq MST(C,E)} w(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.113362em;vertical-align:-0.3633619999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5157190000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mrel amsrm mtight">⫅</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3633619999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><br>
我们定义两个子集C1，C2之间差异是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>f</mi><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>w</mi><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Dif(C_1,C_2) = min(w(v_i,v_j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>属于子集C1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>属于子集C2.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>V</mi><mi>j</mi><mo>)</mo><mo>⫅</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(V_i,Vj) \subseteqq E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⫅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 如果子集C1和C2之间没有元素相互连接，定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>f</mi><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">Dif(C_1,C_2) = \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 这种方法原则上可能有问题，因为它反应的仅仅是子集间最小边的权值。但是实际中我们发现效果相当好。并且使用其他中位数或者其他分位数可以增加鲁棒性，但这使得问题变成NP难问题。分割标准的小小改变极大的改变了问题的复杂性。<br>
区域比较谓词通过检查子集之间的差异Dif（C1，C2）是否相对于至少一个组件（Int（C1）和Int（C2）中的内部差异较大，来判断一对子集之间是否存在边界。阈值函数用于控制子集之间的差异必须大于最小内部差异的程度。我们将成对比较谓词定义为，<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>if Dif(C1,C2)&gt; MInt(C1,C2)</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">D(C_1,C_2) = \begin{cases} true&amp; \text{if Dif(C1,C2)&gt; MInt(C1,C2)}\\ false&amp; \text{otherwise} \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if Dif(C1,C2)&gt; MInt(C1,C2)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mn>1</mn><mo separator="true">,</mo><mi>C</mi><mn>2</mn><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>I</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mn>1</mn><mo>)</mo><mo>+</mo><mi>t</mi><mo>(</mo><mi>C</mi><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>I</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>C</mi><mn>2</mn><mo>)</mo><mo>+</mo><mi>t</mi><mo>(</mo><mi>C</mi><mn>2</mn><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Mint(C1,C2) = min(Int(C1)+t(C1), Int(C2)+t(C2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>,阈值函数t(C)控制着两个子集之间的相似程度。Int(C)不能很好表达出集合的特征，例如当集合C只有一个元素，Int(C)为0，显然不合理。我们使用阈值函数来调节，t(C) = k / |C|, k是一个常数。也就是说，对于小部件，我们需要更有力的边界证据。在实践中，k设置了一个观察范围，因为k越大，就越倾向于使用更大的组件。但是请注意，k不是最小组件尺寸。当相邻组件之间的差异非常大时，允许使用较小的组件。<br>
任何一个分量的非负函数都可以用于τ，而不需要改变第4节中的算法结果。例如，可以通过定义τ，使分割方法更倾向于某些形状的组件，对于不符合某些期望形状的组件，τ值较大，而对于具有特定形状的组件，τ较小。这将导致分割算法积极地合并形状不理想的组件。这种形状偏好可能与偏好不长且薄的构件一样弱（例如，使用周长与面积的比率），也可能与偏好与特定形状模型匹配的构件一样强烈。请注意，这样做的结果不仅仅是所需形状的组件，但是对于任何两个相邻组件，其中一个组件将是所需形状的组件。<br>
#4、算法及其性质<br>
在本节中，我们将描述和分析一种使用上述决策准则D生成分割的算法。根据以下定义，我们将证明由该算法生成的分割既不太粗也不太细。<br>
定义一：如果没有足够的证据说明区域一和区域二之间有边界的存在，那么这个分割就太精细了<br>
定义二：当一个分割可以进一步划分为不太精细的分割时，该分割就太粗糙了.(即可以继续划分)<br>
性质一：对于任何图来说，都存在一个既不精细又不粗糙的分割<br>
现在我们考虑分割算法，它和Kruskal的最小生成树算法密切相关。它可以在O（mlogm）时间内运行，其中m是图中的边数。<br>
算法一：输入 是图G(V, E)，n个顶点m条边。输入是顶点V的一个分割<br>
0. 对于权值E进行非递减排序<br>
1. 开始每个顶点各自为一组<br>
2. 重复第三步<br>
3. 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mi mathvariant="normal">和</mi><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_i和V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之间有一条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">E_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>联系，并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mi mathvariant="normal">和</mi><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">V_i和V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不属于同一集合且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><msub><mi>E</mi><mi>q</mi></msub></msub></mrow><annotation encoding="application/x-tex">W_{E_q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03065em;vertical-align:-0.34731999999999996em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833100000000004em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span></span></span></span>是比两个集合内部的距离Int(C)更小，那么合并这两个集合。<br>
我门使用算法 一得到一个分割，遵循既不太精细又不粗糙的全局特性。尽管这个算法是贪心的，但结果还是满足这些全局性质。此外，我们还证明了在该算法的第0步中选择的任何可能的非减边缘权重排序都会产生相同的分割结果。<br>
##4.1算法实现和时间复杂度<br>
我们使用一个不相交的集合森林来实现算法。算法的时间可以分为两部分，一部分是是第0步排序，O(mlogm)，另一部分第1-3步，时间O(m<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\alpha(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>)，其中α是增长非常慢的逆阿克曼函数。两个集合的合并我们使用并查集，每条边最多有三个不相交的集合运算。如果我们知道Int和每个分量的大小，就可以在常数时间内完成每个边的MInt的计算。为一个子集维护Int可以在每次合并的恒定时间内完成，因为子集MST中的最大权重边缘就是导致合并的边缘。这是因为引理1意味着导致合并的边是被合并的两个集合之间的最小权重边。合并后的集合大小只是合并的两个子集大小的总和。<br>
#5、结果<br>
首先我们考虑单色（强度）图像的情况。彩色图像被处理为三个单独的单色图像，如下所述。与其他基于图的图像分割方法（例如[14,18,19]）一样，我们定义了一个无向图g=（V，e），其中每个图像像素pi都有一个对应的顶点vi∈V。边缘集E是通过连接8连通意义上的相邻像素对来构造的（可以使用任何其他局部邻域）。这将产生一个m=O（n）的图，因此对于n个图像像素，分割算法的运行时间是O（nlogn）。我们使用基于边缘连接的像素之间绝对强度差异的边缘权重函数，<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mo>(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>)</mo><mo>)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>I</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo><mo>−</mo><mi>I</mi><mo>(</mo><msub><mi>p</mi><mi>j</mi></msub><mo>)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">w((v_i, v_j)) = |I(p_i) - I(p_j)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">I(p_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>代表pi点像素值。通过我们会在计算边的权重前使用高斯模糊 来平滑图像，来消除数字化伪影。我们总是使用σ=0.8的高斯函数，它不会对图像产生任何可见的变化，但有助于去除伪影。<br>
对于彩色图像，我们运行该算法三次，分别针对红色、绿色和蓝色平面，然后将这三组分量相交。具体地说，当两个相邻像素出现在三个颜色平面分割的同一个分量中时，我们将它们放在同一个分量中。或者，我们可以在一个图上只运行一次该算法，其中边缘权值测量某个颜色空间中像素之间的距离，但是实验上，我们通过以刚才描述的方式对每个颜色平面的分段进行相交，获得了更好的结果。<br>
该算法有一个运行时参数，即用于计算阈值函数τ的k值。因此k有效地设置了一个观察范围，k越大，就越倾向于较大的成分。根据图像的分辨率以及细节在场景中的重要程度，我们在本节（以及整篇文章）中的示例使用了两种不同的参数设置。例如，在COIL数据库的128×128图像中，我们使用k=150。在320×240或更大的图像中，例如街道场景和棒球运动员，我们使用k=300。<br>
图2中的第一个图像显示了一个街道场景。注意，通往围栏的草坡有很大的变化。我们的算法正是为了处理这种可变性（回想一下图1中合成示例中的高可变性区域）。第二幅图像显示了分割，每个区域都被分配了一个随机颜色。算法发现的六个最大的组成部分是：围栏后面的三个草地区域、草地斜坡、货车和道路。左下角道路的缺失部分是彩色图像中一个明显不同的区域，从中可以计算出该分割（由于成像伪影造成的斑点）。注意，由于镜面反射，面包车的颜色也不统一，但这些反光效果很差，因此它们被视为内部变化，并合并到一个区域中。<br>
图3中的第一个图像显示了两个棒球运动员。 与前面的示例一样，这里的草丛区域变化很大。 由于布料上的褶皱，运动员的制服也有很大的差异。 第二张图片显示了分割。 该算法发现的六个最大组成部分是：后墙，大都会队徽，一个大草丛区域（包括顶部玩家下方的部分墙壁），两个玩家的制服中的每一个，以及第二个队员下方的一个小草丛 播放器。 较大的草丛区域包括墙壁的一部分，这是因为该区域的变化相对较大，并且草与墙壁之间的强度存在长期缓慢的变化（没有明显的边界证据）。 由于布的褶皱，该“边界”的大小与运动员制服内的边界类似。<br>
图4显示了室内场景图像的算法结果，其中细节和较大的结构在感知上都很重要。请注意，分割保留了小区域，例如人们佩戴的姓名标签和窗户后面的东西，同时为高可变性区域创建单个较大区域，例如靠近图像顶部的空调管道、衣服和家具。此图还显示，有时会发现一些小的“边界区域”，例如在夹克或衬衫的边缘。之所以会出现这样的狭窄区域，是因为在两个相邻区域的颜色和强度之间有一个或两个像素宽的区域。这在任何基于网格图的分割方法中都很常见。如果需要，可以通过去除颜色或强度接近相邻区域平均值的细长区域来消除这些区域。<br>
图5显示了COIL图像数据库中的三个简单对象。每个区域显示的是我们的算法找到的最大区域，它不是黑色背景的一部分。请注意，这些对象中的每一个在对象的面上都有一个很大的强度梯度，但是这些区域是正确分割的。这说明了算法设计用来处理的另一种情况，即由于光照而导致的强度缓慢变化。<br>
#6、最近邻图结果<br>
一种常见的图像分割方法是将每个像素映射到某个特征空间中的一个点，然后找到相似点的簇（例如[3,4,9]）。在本节中，我们将研究使用第4节中基于图的分割算法，以便找到类似点的聚类。在这种情况下，图G=（V，E）具有与每个特征点（每个像素）相对应的顶点，并且在特征空间中存在连接相邻的特征点vi和vj的边（vi，vj），而不是使用图像网格中的相邻像素。有几种可能的方法可以确定哪些特征点通过边连接。我们将每个点连接到固定数量的最近邻居。另一种可能性是使用固定距离d内的所有邻域。在任何情况下，最好避免考虑所有O（n2）对特征点。<br>
边缘的权重w（vi，vj）是特征空间中两个对应点之间的距离。对于这里展示的实验，我们将每个像素映射到特征点（x，y，r，g，b），其中（x，y）是像素在图像中的位置，（r，g，b）是像素的颜色值。我们使用点之间的L2（欧几里德）距离作为边缘权重，尽管其他距离函数也是可能的。<br>
内部差异度量Int（C）对特征空间中的点有一个相对简单的潜在直觉。它规定了将包含在C中的一组特征点连接到特征空间中的单个体积所需的最小膨胀半径。考虑用半径为r的球代替每个特征点。从MST的定义可以看出，只有当r≥Int（C）/2时，这些球的结合才会形成一个单一的连接体。组件之间的差异，Dif（C1，C2）也有一个简单的潜在直觉。它规定了将至少一个C1点连接到C2点所需的最小扩张半径。因此，我们的分割技术与[4]的工作密切相关，后者类似地采用了基于参数空间中扩张点的聚类方法（然而，它们首先使用我们没有执行的数据的新转换，然后使用固定的扩展半径，而不是我们使用的变量）。<br>
我们不是构造一个完整的图——所有的点都是彼此的邻居，而是为每个点找到一个小数目的邻居。这使得n个图像像素具有O（n）边，并且O（nlogn）时间分割方法的总运行时间。有许多可能的方法可以为每个点选择一个固定数量的邻居。我们使用ANN算法[1]来寻找每个点的最近邻。该算法在实际应用中速度相当快，给出了一个包含几十万个点的5维特征空间。人工神经网络方法还可以找到近似的最近邻，这比查找实际的最近邻更快。对于这里报告的示例，我们使用每个像素的十个最近邻来生成图形的边。<br>
与上一节（图像网格用于定义图形）的主要区别之一是，特征空间中最近的邻居捕捉到的图像在空间上更非局部属性。在网格图的情况下，图中的所有邻居都是图像中的邻居。在这里，点在图像中可能相距很远，但仍然是少数几个最近的相邻点（如果它们的颜色高度相似并且中间的图像像素具有不同的颜色）。例如，这可能导致分割图像中断开的区域，而在网格图的情况下不会发生这种情况。<br>
图6显示了来自[12]和[8]的合成图像及其分割，使用k=150且没有平滑处理（σ=0）。在这个例子中，空间上不相连的区域不会反映出有趣的场景结构，但是我们将在下面看到一些例子。<br>
对于本节中的其余示例，我们使用k=300和σ=0.8，如前一节所述。首先，我们注意到最近邻图产生的结果与网格图相似，在图像中感知显著区域在空间上是连接的。例如，在上一节中考虑的街道场景和棒球运动员场景使用最近邻图或网格图生成非常相似的分段，通过将图7中的结果与图2和图3中的结果进行比较可以看出这一点。<br>
图8显示了使用最近邻图的另外两个示例。这些结果是不可能实现的网格图方法，因为某些感兴趣的区域在空间上是不连通的。第一个例子展示了一个花圃，在这里红色花草在图像的前景中在空间上不相交，然后在背景中融合在一起。大多数这些花被合并到一个区域中，这是用网格图方法无法实现的。图8中的第二个示例显示了晚上的埃菲尔铁塔。亮黄色的光形成了一个空间上不相连的区域。这些例子表明，该分割方法与最近邻图的使用相结合，可以捕捉图像的高层次属性，同时保留感知上重要的区域边界。<br>
#7、总结<br>
本文介绍了一种新的基于成对区域比较的图像分割方法。我们已经证明，分割过粗或过细的概念可以用测量一对区域之间边界的证据的函数来定义。我们的分割算法可以做出简单的贪婪决策，但是根据特定的区域比较函数，生成的分割既不太粗糙也不太细的全局特性。对于m个图边，该方法在O（mlogm）时间内运行，并且在实践中运行速度也很快，一般只需几秒钟。<br>
我们使用的成对区域比较谓词考虑了两个区域之间的最小权重边缘来衡量它们之间的差异。因此，我们的算法将合并两个区域，即使它们之间有一个单一的低权重边缘。这并不像它最初出现的那样是一个问题，部分原因是该边缘权重仅与每个组件的最小生成树边缘进行比较。例如，第5节和第6节中考虑的例子说明了该方法能够捕获复杂图像的许多感知重要方面的分割。尽管如此，在确定没有证据表明两个地区之间存在边界之前，人们可以设想需要不止一个廉价连接的措施。解决这个问题的一种自然方法是使用分位数而不是最小边缘权重。然而，在这种情况下，找到一个既不太粗也不太细的细分是一个NP难题（如附录所示）。我们的算法是独一无二的，因为它不仅效率很高，而且能捕捉到图像的非局部特性。<br>
我们已经用两种不同的图形演示了我们的图像分割算法。第一种方法使用图像网格来定义图像像素之间的局部邻域，并测量每对邻域之间在强度（或颜色）上的差异。第二种方法将图像像素映射到特征空间中的点，该空间组合了（x，y）位置和（r，g，b）颜色值。图形中的边连接此要素空间中靠近的点。该算法在使用这两种图形时都能获得很好的结果，但后一种类型的图形可以更直观地捕捉图像的全局方面。<br>
图像分割仍然是一个具有挑战性的问题，然而，通过引入基于图的算法，我们开始取得实质性的进展，这些算法既有助于加深我们对问题的理解，也有助于提供有用的计算工具。这里报道的工作和标准化切割方法[14]只是这些最新进展的几个例子。<br>
——————————————————————————————————————————<br>
个人理解：<br>
论文里提出的图像分割方法是将整幅图看作一个无向图，每个像素点看作顶点，像素点之间的边有一个权重值，代表两个像素点的相异度(可以是灰度、梯度等)。先定义一个组内部的距离：最小生成树中所含边的最大权重w0，如果一个组。再定义组和组之间的距离：两个组之间有一些点有边相连，这些边中最小权值就是两个组的距离dif，如果没有边相连那么dif是正无穷。定义谓词D：如果dif &gt; min(w0 + t0, w1 + t1)(t0是一个阈值函数，用来控制相异程度)，那么就将两个组合并。<br>
算法：<br>
1. 对图中所有的边进行非递减排序。(O(mlogm)),m是边的个数<br>
2. 每个顶点各自为1组<br>
3. 如果两个组符合谓词D，就合并<br>
可以在处理之前对图像进行高斯模糊，论文中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>取0.8，认为它不会对图像产生任何可见的变化，但有助于去除伪影。<br>
<a href="http://cs.brown.edu/people/pfelzens/segment/segment.zip">原论文C++代码</a><br>
<a href="https://github.com/salaee/pegbis">基于Python代码</a> 代码的输出图像是0-255的float类型图像，不能正常显示，需要在main.py的80行加入 output /= 255.0归一化到0-1.0</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://secrul.github.io/post/selective-search-for-object-recognition/">
                  <h3 class="post-title">
                    Selective Search for Object Recognition
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
